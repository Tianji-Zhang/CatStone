function Solution = NRsolver(n_var, n_cell, n_dim,J_info,S_info,O_info,var_n,dt,t)
%A Solver Test
%   Should be automatically generated by Scheme

%% Define variables & Functions
n_eqn = n_var;
cell_index_list = 1:n_cell;
dim_index_list = 1:(n_dim*2+1);
var_index_list = 1:n_var;
eqn_index_list = 1:n_eqn;

var_table = zeros(n_var, n_cell);
var_old_table = zeros(n_var, n_cell);
var_1D_index = @(cell_index, var_i) ((cell_index - 1)* n_var + var_i);

adj_table = zeros(n_cell, 2 * n_dim + 1);
adj_table(:,end) = cell_index_list';
adj_table(1:end-1,2) = adj_table(2:end,end);
adj_table(2:end,1) = adj_table(1:end-1,end);

adj_index = @(cell_index ,dim_i,adj_table) adj_table(cell_index,dim_i);
%adj_index = @(cell_index ,dim_i) adj_table(cell_index,dim_i);
% adj_1D_index = @(cell_index ,dim_i) cell_index + dim_i - 1;

dvar_table = zeros(n_var, n_cell);
% dvar_1D_index = var_1D_index;

R_table = zeros(n_var, n_cell);
% R_1D_index = var_1D_index;

Jacob_mat = zeros(n_var * n_cell);
% index map to jacobian matrix, row: cell(eqns), col: cell(vars)
Jacob_1D_adj_index = @(cell_index,dim_i,adj_table)(n_eqn*n_var*n_cell)*(adj_index(cell_index,dim_i,adj_table)'-1);
Jacob_1D_adjvar_index = @(var_i)(n_eqn*n_cell)*(var_i-1);
Jacob_1D_cell_index = @(cell_index)n_eqn*(cell_index-1);
Jacob_1D_celleqn_index = @(eqn_i)eqn_i;
Jacob_1D_index_mat = @(cell_index, dim_i, var_i, eqn_i,adj_table) Jacob_1D_adj_index(cell_index, dim_i,adj_table) + Jacob_1D_adjvar_index(var_i) + Jacob_1D_cell_index(cell_index) + Jacob_1D_celleqn_index(eqn_i);

%Note: 
%1. dim_i = n_dim + 1 when it refers to cell center;
%2. cell_index is an array, but only get a part of the center cells;


%% Initialization

t_n = 1;
time = 0;
tolerance = 1e-4;
dvar_table(:) = 1;
solver_record = zeros(n_var, n_cell,ceil(time/dt));
% initial condition of unknowns
for i_var = 1:1:length(var_n)
    var_table(i_var, :) = var_n(i_var);
end

%% Main loop
max_dx = @(dx, x) max(max(abs(dx ./ x)));
while time <= t
    
    var_old_table = var_table;
    while max_dx(dvar_table,var_table) >= tolerance
        
        R_table(:) = 0;
        dvar_table(:) = 0;
        Jacob_mat(:) = 0;
        
        for i_O = 1:1:length(O_info)
            for i_eqn = 1:1:length(O_info.O_eqn)
                % Old terms as constants on the residual side
                cell_index = O_info(i_O). index{1};
                R_values = R_table(var_1D_index(cell_index,i_eqn));
                O_values = O_info(i_O). O_eqn{i_eqn}(cell_index,var_old_table);
                R_table(var_1D_index(cell_index,i_eqn)) = O_values + R_values;
            end
        end
        
        for i_S = 1:1:length(S_info)
            for i_eqn = 1:1:length(S_info.S_eqn)
                
                % calc residual
                cell_index = S_info(i_S). index{1};
                R_values = R_table(var_1D_index(cell_index,i_eqn));
                S_values = S_info(i_S). S_eqn{i_eqn}(cell_index,var_table);
                R_table(var_1D_index(cell_index,i_eqn)) = S_values + R_values;
                
                % calc residual derivative
                i_dim = n_dim * 2 + 1; %center
                for i_var = 1:1:length(S_info.dSdv_i);
                    Jacob_values = Jacob_mat(Jacob_1D_index_mat(cell_index, i_dim, i_var, i_eqn,adj_table));
                    dSdv_i_values = S_info(i_S). dSdv_i{i_eqn,i_var}(cell_index,var_table);
                    Jacob_mat(Jacob_1D_index_mat(cell_index, i_dim, i_var, i_eqn,adj_table)) = dSdv_i_values + Jacob_values;
                end
                
            end
        end
        
        for i_J = 1:1:length(J_info)
            for i_dim = 1:n_dim*2
                for i_eqn = eqn_index_list
                    
                    % calc residual
                    cell_index = J_info(i_J). dir_index{i_dim};
                    if isempty(cell_index)
                        continue; % A flaw should be fixed later
                    end
                    R_values = R_table(var_1D_index(cell_index,i_eqn));
                    J_values = J_info(i_J). J_eqn{i_eqn}(cell_index,var_table,i_dim,adj_index,adj_table);
                    R_table(var_1D_index(cell_index,i_eqn)) = J_values + R_values;
                    
                    % calc derivatives for both i and adjacents in Jacobian
                    for i_var = var_index_list
                                                
                        % adj
                        % Not good,need to be improved
                        % boundary?
                        % need to be improved
                        if min(adj_index(cell_index,i_dim,adj_table))>0
                            Jacob_values = Jacob_mat(Jacob_1D_index_mat(cell_index, i_dim, i_var, i_eqn,adj_table));
                            J_values = J_info(i_J). dJdv_adj{i_eqn}(cell_index, var_table,i_dim,adj_index,adj_table);
                        end
                        % i of center cell
                        Jacob_values = Jacob_mat(Jacob_1D_index_mat(cell_index, n_dim*2+1, i_var, i_eqn,adj_table));
                        J_values = J_info(i_J). dJdv_i{i_eqn}(cell_index, var_table,i_dim,adj_index,adj_table);
                        Jacob_mat(Jacob_1D_index_mat(cell_index, 2*n_dim+1, i_var, i_eqn,adj_table)) = J_values + Jacob_values;
                    end
                    
                end
            end
        end
        
        dvar_table(:) = sparse(Jacob_mat)\R_table;
        var_table = var_table + dvar_table;
    end
    
    solver_record(:,:,t_n) = var_table;
    t_n = t_n + 1;
    time = time + dt;
end
    
    Solution = solver_record;
end





